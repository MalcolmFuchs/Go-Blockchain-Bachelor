diff --git a/blockchain/transaction.go b/blockchain/transaction.go
index f6241fb..274c0ec 100644
--- a/blockchain/transaction.go
+++ b/blockchain/transaction.go
@@ -2,9 +2,9 @@ package blockchain
 
 import (
 	"bytes"
+	"crypto/ecdsa"
 	"crypto/ed25519"
 	"crypto/sha256"
-	"encoding/hex"
 	"encoding/json"
 	"fmt"
 
@@ -17,7 +17,6 @@ type Transaction struct {
 	Doctor        []byte              `json:"doctor"`
 	Patient       []byte              `json:"patient"`
 	Signature     []byte              `json:"signature"`
-	Key           []byte              `json:"key"`
 }
 
 type TransactionData struct {
@@ -35,46 +34,36 @@ func PrepareTransactionData(txType, notes, results string) ([]byte, error) {
 	return json.Marshal(data)
 }
 
-func NewTransaction(txType, notes, results, doctorPublicKeyHex, patientPublicKeyHex string, keyHex string) (*Transaction, error) {
-	// Wandelt Doctor- und Patient-Public-Key und den Key von Hex-String zu []byte um
-	doctor, err := hex.DecodeString(doctorPublicKeyHex)
-	if err != nil {
-		return nil, fmt.Errorf("failed to decode doctor public key: %v", err)
-	}
-
-	patient, err := hex.DecodeString(patientPublicKeyHex)
+func NewTransaction(txType, notes, results string, senderPrivKey *ecdsa.PrivateKey, recipientPubKey *ecdsa.PublicKey) (*Transaction, error) {
+	// Bereite die Transaktionsdaten vor
+	plaintext, err := PrepareTransactionData(txType, notes, results)
 	if err != nil {
-		return nil, fmt.Errorf("failed to decode patient public key: %v", err)
+		return nil, fmt.Errorf("failed to prepare transaction data: %v", err)
 	}
 
-	key, err := hex.DecodeString(keyHex)
+	senderEcdhPrivKey, err := utils.EcdsaPrivToEcdh(senderPrivKey)
 	if err != nil {
-		return nil, fmt.Errorf("failed to decode key: %v", err)
+		return nil, fmt.Errorf("Error during conversion from ecdsa to ecdh private key", err)
 	}
 
-	// Bereite die Transaktionsdaten vor
-	plaintext, err := PrepareTransactionData(txType, notes, results)
+	recipientEcdhPubKey, err := utils.EcdsaPubToEcdh(recipientPubKey)
 	if err != nil {
-		return nil, fmt.Errorf("failed to prepare transaction data: %v", err)
+		return nil, fmt.Errorf("Error during conversion from ecdsa to ecdh public key", err)
 	}
 
 	// Verschlüssele die Daten mit AES-GCM
-	encryptedData, err := utils.EncryptData(plaintext, key)
+	ciphertext, nonce, err := utils.EncryptData(senderEcdhPrivKey, recipientEcdhPubKey, plaintext)
 	if err != nil {
 		return nil, fmt.Errorf("failed to encrypt transaction data: %v", err)
 	}
 
-	// Verschlüssele den AES-Schlüssel mit dem öffentlichen Schlüssel des Patienten
-	encryptedAESKey, err := utils.EncryptAESKeyWithPublicKey(key, patient)
-	if err != nil {
-		return nil, fmt.Errorf("failed to encrypt AES key: %v", err)
-	}
-
 	tx := &Transaction{
-		Doctor:        doctor,
-		Patient:       patient,
-		EncryptedData: encryptedData,
-		Key:           encryptedAESKey, // Der verschlüsselte AES-Schlüssel wird im Key-Feld gespeichert
+		Doctor:  senderPrivKey.X.Bytes(),
+		Patient: recipientPubKey.X.Bytes(),
+		EncryptedData: utils.EncryptedData{
+			Ciphertext: ciphertext,
+			Nonce:      nonce,
+		},
 	}
 
 	// Berechne den Hash der Transaktion
diff --git a/blockchain/transaction_test.go b/blockchain/transaction_test.go
index 303be0e..00e3ce8 100644
--- a/blockchain/transaction_test.go
+++ b/blockchain/transaction_test.go
@@ -35,12 +35,6 @@ func TestValidateTransaction(t *testing.T) {
 		t.Fatalf("Failed to generate authority node keys: %v", err)
 	}
 
-	// Generiere einen zufälligen AES-Schlüssel und encodiere ihn als Hex
-	validKeyHex, err := generateRandomHexKey(32) // 32 Bytes für AES-256
-	if err != nil {
-		t.Fatalf("Failed to generate random AES key: %v", err)
-	}
-
 	// Erstelle eine Transaktion (ohne Signatur)
 	tx, err := NewTransaction(
 		"Checkup",
@@ -48,7 +42,6 @@ func TestValidateTransaction(t *testing.T) {
 		"All normal",
 		hex.EncodeToString(doctorPub),
 		hex.EncodeToString(patientPub),
-		validKeyHex,
 	)
 	if err != nil {
 		t.Fatalf("Failed to create transaction: %v", err)
diff --git a/cmd/api.go b/cmd/api.go
index 9916851..6fe031b 100644
--- a/cmd/api.go
+++ b/cmd/api.go
@@ -95,7 +95,6 @@ func (authorityNode *AuthorityNode) AddTransactionHandler(w http.ResponseWriter,
 		transactionData.Results,
 		transactionData.Doctor,
 		transactionData.Patient,
-		transactionData.Key,
 	)
 	if err != nil {
 		http.Error(w, fmt.Sprintf("failed to create transaction: %v", err), http.StatusInternalServerError)
diff --git a/cmd/client_node.go b/cmd/client_node.go
index fa0339d..2dbbe34 100644
--- a/cmd/client_node.go
+++ b/cmd/client_node.go
@@ -6,6 +6,7 @@ import (
 	"encoding/json"
 	"fmt"
 	"net/http"
+	"time"
 
 	"github.com/MalcolmFuchs/Go-Blockchain-Bachelor/blockchain"
 )
@@ -50,10 +51,22 @@ func (n *Node) ForwardTransaction(transaction *blockchain.Transaction) error {
 	return nil
 }
 
-func (a *Node) Listen(addr string) {
+func (n *Node) Listen(addr string) {
 	http.ListenAndServe(addr, nil)
 }
 
+// check if conditions are met every 5th minute with sleep
+func (n *Node) StartSyncRoutine() {
+	// Create the ticker inside the Go routine
+	ticker := time.NewTicker(10 * time.Second)
+	defer ticker.Stop()
+
+	for range ticker.C {
+		// Sync Blockchain
+    n.AuthorityNodeDiscovery()
+	}
+}
+
 // Give the ClientNOde the publicKey of AuthorityNode
 func (n *Node) AuthorityNodeDiscovery() {
 	resp, err := http.Get(fmt.Sprintf("http://%s/getPublicKey", n.AuthorityNodeAddress))
diff --git a/cmd/node.go b/cmd/node.go
index 71e5ec8..205b302 100644
--- a/cmd/node.go
+++ b/cmd/node.go
@@ -27,7 +27,7 @@ var nodeCmd = &cobra.Command{
 			node := NewNode(clientPrivateKey, nil, authorityAddress)
 			fmt.Printf("Starting Client Node... Connecting to Authority Node at %s\n", authorityAddress)
 			node.SetupNodeRoutes()
-			go node.AuthorityNodeDiscovery()
+      go node.StartSyncRoutine()
 			node.Listen(":" + port)
 		}
 	},
diff --git a/go.mod b/go.mod
index 5daa04f..3cf4e7e 100644
--- a/go.mod
+++ b/go.mod
@@ -8,6 +8,10 @@ require (
 )
 
 require (
+	github.com/davecgh/go-spew v1.1.1 // indirect
 	github.com/inconshreveable/mousetrap v1.1.0 // indirect
+	github.com/pmezard/go-difflib v1.0.0 // indirect
 	github.com/spf13/pflag v1.0.5 // indirect
+	github.com/stretchr/testify v1.9.0 // indirect
+	gopkg.in/yaml.v3 v3.0.1 // indirect
 )
diff --git a/go.sum b/go.sum
index 86de154..ec60802 100644
--- a/go.sum
+++ b/go.sum
@@ -1,12 +1,19 @@
 github.com/cpuguy83/go-md2man/v2 v2.0.4/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=
+github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
+github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
 github.com/inconshreveable/mousetrap v1.1.0 h1:wN+x4NVGpMsO7ErUn/mUI3vEoE6Jt13X2s0bqwp9tc8=
 github.com/inconshreveable/mousetrap v1.1.0/go.mod h1:vpF70FUmC8bwa3OWnCshd2FqLfsEA9PFc4w1p2J65bw=
+github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
+github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
 github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=
 github.com/spf13/cobra v1.8.1 h1:e5/vxKd/rZsfSJMUX1agtjeTDf+qv1/JdBF8gg5k9ZM=
 github.com/spf13/cobra v1.8.1/go.mod h1:wHxEcudfqmLYa8iTfL+OuZPbBZkmvliBWKIezN3kD9Y=
 github.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=
 github.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
+github.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=
+github.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
 golang.org/x/crypto v0.28.0 h1:GBDwsMXVQi34v5CCYUm2jkJvu4cbtru2U4TN2PSyQnw=
 golang.org/x/crypto v0.28.0/go.mod h1:rmgy+3RHxRZMyY0jjAJShp2zgEdOqj2AO7U0pYmeQ7U=
 gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
+gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
 gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
diff --git a/utils/crypto.go b/utils/crypto.go
index 26b0e75..0fa783b 100644
--- a/utils/crypto.go
+++ b/utils/crypto.go
@@ -3,16 +3,21 @@ package utils
 import (
 	"crypto/aes"
 	"crypto/cipher"
+	"crypto/ecdh"
 	"crypto/ecdsa"
 	"crypto/ed25519"
 	"crypto/elliptic"
 	"crypto/rand"
 	"crypto/sha256"
+	"crypto/x509"
 	"encoding/hex"
+	"encoding/pem"
 	"fmt"
 	"io"
+	"math/big"
+	"os"
 
-	"golang.org/x/crypto/curve25519"
+	"golang.org/x/crypto/hkdf"
 )
 
 type EncryptedData struct {
@@ -20,77 +25,139 @@ type EncryptedData struct {
 	Nonce      []byte `json:"nonce"`
 }
 
-func EncryptData(plaintext []byte, key []byte) (EncryptedData, error) {
-	block, err := aes.NewCipher(key)
+func loadPrivateKey(filename string) (*ecdsa.PrivateKey, *ecdsa.PublicKey, error) {
+	// Read the private key PEM file
+	pemData, err := os.ReadFile(filename)
 	if err != nil {
-		return EncryptedData{}, fmt.Errorf("failed to create cipher: %v", err)
+		return nil, nil, fmt.Errorf("failed to read private key file: %v", err)
 	}
 
-	aesGCM, err := cipher.NewGCM(block)
-	if err != nil {
-		return EncryptedData{}, fmt.Errorf("failed to create GCM: %v", err)
+	// Decode the PEM block
+	block, _ := pem.Decode(pemData)
+	if block == nil || block.Type != "EC PRIVATE KEY" {
+		return nil, nil, fmt.Errorf("failed to decode PEM block containing private key")
 	}
 
-	nonce := make([]byte, aesGCM.NonceSize())
-	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
-		return EncryptedData{}, fmt.Errorf("failed to generate nonce: %v", err)
+	// Parse the ECDSA private key
+	privKey, err := x509.ParseECPrivateKey(block.Bytes)
+	if err != nil {
+		return nil, nil, fmt.Errorf("failed to parse EC private key: %v", err)
 	}
 
-	ciphertext := aesGCM.Seal(nil, nonce, plaintext, nil)
+	// The public key is embedded in the private key
+	pubKey := &privKey.PublicKey
 
-	return EncryptedData{
-		Ciphertext: ciphertext,
-		Nonce:      nonce,
-	}, nil
+	return privKey, pubKey, nil
 }
 
-func DecryptData(encrypted EncryptedData, key []byte) ([]byte, error) {
-	block, err := aes.NewCipher(key)
+func EncryptData(senderPrivKey *ecdh.PrivateKey, recipientPubKey *ecdh.PublicKey, plaintext []byte) ([]byte, []byte, error) {
+	// Perform ECDH key exchange to derive the shared secret
+	sharedSecret, err := senderPrivKey.ECDH(recipientPubKey)
 	if err != nil {
-		return nil, fmt.Errorf("failed to create cipher: %v", err)
+		return nil, nil, fmt.Errorf("ECDH key exchange failed: %v", err)
 	}
 
+	// Derive symmetric key using HKDF
+	salt := []byte("ECDH encryption")
+	info := []byte("encryption key")
+	hkdf := hkdf.New(sha256.New, sharedSecret, salt, info)
+	symmetricKey := make([]byte, 32)
+	if _, err := io.ReadFull(hkdf, symmetricKey); err != nil {
+		return nil, nil, err
+	}
+
+	// Encrypt data using AES-GCM
+	block, err := aes.NewCipher(symmetricKey)
+	if err != nil {
+		return nil, nil, err
+	}
 	aesGCM, err := cipher.NewGCM(block)
 	if err != nil {
-		return nil, fmt.Errorf("failed to create GCM: %v", err)
+		return nil, nil, err
 	}
+	nonce := make([]byte, aesGCM.NonceSize())
+	if _, err := rand.Read(nonce); err != nil {
+		return nil, nil, err
+	}
+	ciphertext := aesGCM.Seal(nil, nonce, plaintext, nil)
+	return ciphertext, nonce, nil
+}
 
-	plaintext, err := aesGCM.Open(nil, encrypted.Nonce, encrypted.Ciphertext, nil)
+func DecryptData(recipientPrivKey *ecdh.PrivateKey, senderPubKey *ecdh.PublicKey, ciphertext, nonce []byte) ([]byte, error) {
+	// Perform ECDH key exchange to derive the shared secret
+	sharedSecret, err := recipientPrivKey.ECDH(senderPubKey)
 	if err != nil {
-		return nil, fmt.Errorf("failed to decrypt data: %v", err)
+		return nil, fmt.Errorf("ECDH key exchange failed: %v", err)
 	}
 
+	// Derive symmetric key using HKDF
+	salt := []byte("ECDH encryption")
+	info := []byte("encryption key")
+	hkdf := hkdf.New(sha256.New, sharedSecret, salt, info)
+	symmetricKey := make([]byte, 32)
+	if _, err := io.ReadFull(hkdf, symmetricKey); err != nil {
+		return nil, err
+	}
+
+	// Decrypt data using AES-GCM
+	block, err := aes.NewCipher(symmetricKey)
+	if err != nil {
+		return nil, err
+	}
+	aesGCM, err := cipher.NewGCM(block)
+	if err != nil {
+		return nil, err
+	}
+	plaintext, err := aesGCM.Open(nil, nonce, ciphertext, nil)
+	if err != nil {
+		return nil, err
+	}
 	return plaintext, nil
 }
 
-func EncryptAESKeyWithPublicKey(aesKey []byte, patientPublicKey ed25519.PublicKey) ([]byte, error) {
-	// Konvertiere Ed25519-Public-Key zu X25519-Public-Key
-	x25519PubKey := ed25519PublicKeyToX25519(patientPublicKey)
-
-	// Generiere einen ECDH-Privat-Key
-	var ecdhPrivKey [32]byte
-	if _, err := rand.Read(ecdhPrivKey[:]); err != nil {
-		return nil, fmt.Errorf("failed to generate ECDH private key: %v", err)
+func SignTransaction(senderPrivKey *ecdsa.PrivateKey, transactionData []byte) ([]byte, []byte, error) {
+	hash := sha256.Sum256(transactionData)
+	r, s, err := ecdsa.Sign(rand.Reader, senderPrivKey, hash[:])
+	if err != nil {
+		return nil, nil, err
 	}
+	return r.Bytes(), s.Bytes(), nil
+}
 
-	// Berechne das gemeinsame Geheimnis
-	sharedSecret, err := curve25519.X25519(ecdhPrivKey[:], x25519PubKey)
+func VerifySignature(senderPubKey *ecdsa.PublicKey, transactionData, rBytes, sBytes []byte) bool {
+	hash := sha256.Sum256(transactionData)
+	var r, s big.Int
+	r.SetBytes(rBytes)
+	s.SetBytes(sBytes)
+	return ecdsa.Verify(senderPubKey, hash[:], &r, &s)
+}
+
+func EcdsaPrivToEcdh(ecdsaPrivKey *ecdsa.PrivateKey) (*ecdh.PrivateKey, error) {
+	ecdhCurve := ecdh.P256()
+	ecdhPrivKey, err := ecdhCurve.NewPrivateKey(ecdsaPrivKey.D.Bytes())
 	if err != nil {
-		return nil, fmt.Errorf("failed to compute shared secret: %v", err)
+		fmt.Println("Error converting ECDSA private key to ECDH private key:", err)
+		return nil, err
 	}
 
-	// Hash des gemeinsamen Geheimnisses verwenden als AES-Schlüssel
-	hashedSecret := sha256.Sum256(sharedSecret)
+	return ecdhPrivKey, nil
+}
 
-	// Verschlüssele den AES-Schlüssel mit dem gehashten gemeinsamen Geheimnis
-	encryptedAESKey, err := EncryptData(aesKey, hashedSecret[:])
+func EcdsaPubToEcdh(ecdsaPubKey *ecdsa.PublicKey) (*ecdh.PublicKey, error) {
+	ecdhCurve := ecdh.P256()
+	ecdhPubKey, err := ecdhCurve.NewPublicKey(SerializePublicKey(ecdsaPubKey))
 	if err != nil {
-		return nil, fmt.Errorf("failed to encrypt AES key: %v", err)
+		fmt.Println("Error converting ECDSA public key to ECDH public key:", err)
+		return nil, err
 	}
 
-	// In diesem Beispiel kombinieren wir den ECDH-Privat-Key und den verschlüsselten AES-Schlüssel
-	// In der Praxis solltest du den ECDH-Privat-Key nicht übertragen
-	return append(ecdhPrivKey[:], encryptedAESKey.Ciphertext...), nil
+	return ecdhPubKey, nil
+}
+
+// Serialize the ECDSA public key in uncompressed form (X and Y coordinates concatenated)
+func SerializePublicKey(pubKey *ecdsa.PublicKey) []byte {
+	// Uncompressed public key format: 0x04 || X || Y
+	return append([]byte{0x04}, append(pubKey.X.Bytes(), pubKey.Y.Bytes()...)...)
 }
 
 func ed25519PublicKeyToX25519(edPubKey ed25519.PublicKey) []byte {
@@ -133,13 +200,6 @@ func GenerateECDSAKeys() (*ecdsa.PrivateKey, error) {
 	return privateKey, nil
 }
 
-// Helper function to serialize a public key by concatenating X and Y coordinates
-func serializePublicKey(publicKey *ecdsa.PublicKey) []byte {
-	xBytes := publicKey.X.Bytes()
-	yBytes := publicKey.Y.Bytes()
-	return append(xBytes, yBytes...)
-}
-
 func GenerateAESKey() ([]byte, error) {
 	key := make([]byte, 32) // 256 Bits
 	if _, err := io.ReadFull(rand.Reader, key); err != nil {
