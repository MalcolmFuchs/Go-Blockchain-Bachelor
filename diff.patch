diff --git a/.gitignore b/.gitignore
index ec40607..bfc7d53 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,5 @@
 .vscode
 .gitignore
-/components
\ No newline at end of file
+/components
+
+/Go-Blockchain-Bachelor
diff --git a/cmd/api.go b/cmd/api.go
index 19e847e..0f48134 100644
--- a/cmd/api.go
+++ b/cmd/api.go
@@ -8,16 +8,8 @@ import (
 	"github.com/MalcolmFuchs/Go-Blockchain-Bachelor/blockchain"
 )
 
-type API struct {
-	AuthorityNode *AuthorityNode
-}
-
-func NewAPI(authorityNode *AuthorityNode) *API {
-	return &API{AuthorityNode: authorityNode}
-}
-
-func (api *API) GetBlockchainHandler(w http.ResponseWriter, r *http.Request) {
-	blockchainData, err := api.AuthorityNode.Blockchain.GetBlockchainData()
+func (node *Node) GetBlockchainHandler(w http.ResponseWriter, r *http.Request) {
+	blockchainData, err := node.Blockchain.GetBlockchainData()
 	if err != nil {
 		http.Error(w, "failed to get blockchain data", http.StatusInternalServerError)
 		return
@@ -28,7 +20,7 @@ func (api *API) GetBlockchainHandler(w http.ResponseWriter, r *http.Request) {
 	w.Write(blockchainData)
 }
 
-func (api *API) AddTransactionHandler(w http.ResponseWriter, r *http.Request) {
+func (authorityNode *AuthorityNode) AddTransactionHandler(w http.ResponseWriter, r *http.Request) {
 	var transaction blockchain.Transaction
 
 	err := json.NewDecoder(r.Body).Decode(&transaction)
@@ -37,7 +29,7 @@ func (api *API) AddTransactionHandler(w http.ResponseWriter, r *http.Request) {
 		return
 	}
 
-	signature, err := blockchain.SignTransaction(&transaction, api.AuthorityNode.Node.PrivateKey)
+	signature, err := blockchain.SignTransaction(&transaction, authorityNode.PrivateKey)
 	if err != nil {
 		http.Error(w, "failed to sign transaction", http.StatusInternalServerError)
 		return
@@ -45,14 +37,14 @@ func (api *API) AddTransactionHandler(w http.ResponseWriter, r *http.Request) {
 
 	fmt.Println(signature)
 
-	api.AuthorityNode.PendingTransactions = append(api.AuthorityNode.PendingTransactions, &transaction)
+	authorityNode.PendingTransactions = append(authorityNode.PendingTransactions, &transaction)
 
 	w.WriteHeader(http.StatusOK)
 	w.Write([]byte("Transaction added successfully"))
 }
 
-func (api *API) CreateBlockHandler(w http.ResponseWriter, r *http.Request) {
-	block, err := api.AuthorityNode.CreateBlock()
+func (authorityNode *AuthorityNode) CreateBlockHandler(w http.ResponseWriter, r *http.Request) {
+	block, err := authorityNode.CreateBlock()
 	if err != nil {
 		http.Error(w, fmt.Sprintf("failed to create block: %v", err), http.StatusInternalServerError)
 		return
@@ -69,7 +61,7 @@ func (api *API) CreateBlockHandler(w http.ResponseWriter, r *http.Request) {
 	w.Write(blockData)
 }
 
-func (api *API) SyncHandler(w http.ResponseWriter, r *http.Request) {
+func (authorityNode *AuthorityNode) SyncHandler(w http.ResponseWriter, r *http.Request) {
 	var syncRequest SyncRequest
 	if err := json.NewDecoder(r.Body).Decode(&syncRequest); err != nil {
 		http.Error(w, "failed to decode sync request", http.StatusBadRequest)
@@ -79,15 +71,15 @@ func (api *API) SyncHandler(w http.ResponseWriter, r *http.Request) {
 	var syncBlocks []*blockchain.Block
 	syncStartIndex := -1
 
-	for i, block := range api.AuthorityNode.Blockchain.Blocks {
+	for i, block := range authorityNode.Blockchain.Blocks {
 		if fmt.Sprintf("%x", block.Hash) == syncRequest.LastBlockHash {
 			syncStartIndex = i + 1
 			break
 		}
 	}
 
-	if syncStartIndex != -1 && syncStartIndex < len(api.AuthorityNode.Blockchain.Blocks) {
-		syncBlocks = api.AuthorityNode.Blockchain.Blocks[syncStartIndex:]
+	if syncStartIndex != -1 && syncStartIndex < len(authorityNode.Blockchain.Blocks) {
+		syncBlocks = authorityNode.Blockchain.Blocks[syncStartIndex:]
 	}
 
 	syncResponse := SyncResponse{Blocks: syncBlocks}
@@ -102,9 +94,13 @@ func (api *API) SyncHandler(w http.ResponseWriter, r *http.Request) {
 	w.Write(responseBody)
 }
 
-func (api *API) SetupRoutes() {
-	http.HandleFunc("/getBlockchain", api.GetBlockchainHandler)
-	http.HandleFunc("/addTransaction", api.AddTransactionHandler)
-	http.HandleFunc("/createBlock", api.CreateBlockHandler)
-	http.HandleFunc("/sync", api.SyncHandler)
+func (authorityNode *AuthorityNode) SetupAuthorityNodeRoutes() {
+  authorityNode.SetupNodeRoutes()
+	http.HandleFunc("/addTransaction", authorityNode.AddTransactionHandler)
+	http.HandleFunc("/createBlock", authorityNode.CreateBlockHandler)
+	http.HandleFunc("/sync", authorityNode.SyncHandler)
+}
+
+func (node *Node) SetupNodeRoutes() {
+	http.HandleFunc("/getBlockchain", node.GetBlockchainHandler)
 }
diff --git a/cmd/authority_node.go b/cmd/authority_node.go
index 92beadb..9d59829 100644
--- a/cmd/authority_node.go
+++ b/cmd/authority_node.go
@@ -12,20 +12,27 @@ import (
 
 type AuthorityNode struct {
 	PrivateKey          ed25519.PrivateKey        // Private Key des Authority Nodes zur Signierung
-	Blockchain          *blockchain.Blockchain    // Referenz auf die Blockchain-Struktur
 	PendingTransactions []*blockchain.Transaction // Liste der ausstehenden Transaktionen
-	Node                *Node                     // Referenz auf den allgemeinen Node
+	*Node                                         // Referenz auf den allgemeinen Node
 	LastBlockTimestamp  int64                     // Zeitstempel des zuletzt erstellten Blocks
 }
 
-func NewAuthorityNode(privateKey ed25519.PrivateKey, node *Node) *AuthorityNode {
-	return &AuthorityNode{
+func NewAuthorityNode(privateKey ed25519.PrivateKey, publicKey ed25519.PublicKey) *AuthorityNode {
+	node := NewNode(privateKey, publicKey, "localhost:8080")
+
+	authorityNode := &AuthorityNode{
 		PrivateKey:          privateKey,
-		Blockchain:          blockchain.NewBlockchain(privateKey),
 		PendingTransactions: []*blockchain.Transaction{},
 		Node:                node,
 		LastBlockTimestamp:  time.Now().Unix(),
 	}
+
+	// Create Genesis block
+	authorityNode.Blockchain = blockchain.NewBlockchain(privateKey)
+
+	go authorityNode.StartBlockGenerator()
+
+	return authorityNode
 }
 
 func (a *AuthorityNode) AddTransaction(transaction *blockchain.Transaction) {
@@ -76,7 +83,7 @@ func (a *AuthorityNode) AddBlockToBlockchain(block *blockchain.Block) error {
 }
 
 func (a *AuthorityNode) CheckAndCreateBlock() error {
-	if len(a.PendingTransactions) >= 10 || time.Now().Unix()-a.LastBlockTimestamp >= 300 {
+	if len(a.PendingTransactions) >= 10 || (time.Now().Unix()-a.LastBlockTimestamp >= 300 && len(a.PendingTransactions) > 0) {
 		_, err := a.CreateBlock()
 		if err != nil {
 			return fmt.Errorf("failed to create block: %v", err)
@@ -103,3 +110,6 @@ func (a *AuthorityNode) ValidateBlock(block *blockchain.Block) error {
 
 	return nil
 }
+
+// TODO: Build function, that checks if conditions are met every 5th minute with sleep
+func (a *AuthorityNode) StartBlockGenerator() {}
diff --git a/cmd/client_node.go b/cmd/client_node.go
index 8c72612..3f85174 100644
--- a/cmd/client_node.go
+++ b/cmd/client_node.go
@@ -4,6 +4,7 @@ import (
 	"crypto/ed25519"
 	"encoding/hex"
 	"fmt"
+	"net/http"
 
 	"github.com/MalcolmFuchs/Go-Blockchain-Bachelor/blockchain"
 )
@@ -75,3 +76,10 @@ func (n *Node) ForwardTransaction(transaction *blockchain.Transaction) error {
 	fmt.Printf("Forwarding transaction with hash %x to authority node at %s\n", transaction.Hash, n.AuthorityNodeAddress)
 	return nil
 }
+
+func (a *Node) Listen(addr string) {
+  http.ListenAndServe(addr, nil)
+}
+
+// TODO: Build discovery function ()
+func (a *Node) AuthorityNodeDiscovery() {}
diff --git a/cmd/network.go b/cmd/network.go
index bed6370..066df0b 100644
--- a/cmd/network.go
+++ b/cmd/network.go
@@ -1,45 +1,5 @@
 package cmd
 
-import (
-	"fmt"
-	"net"
-	"sync"
-)
-
 type Network struct {
-	Nodes map[string]net.Conn
-	mutex sync.Mutex
-}
-
-func NewNetwork() *Network {
-	return &Network{
-		Nodes: make(map[string]net.Conn),
-	}
-}
-
-func (n *Network) AddNode(address string, conn net.Conn) {
-	n.mutex.Lock()
-	defer n.mutex.Unlock()
-	n.Nodes[address] = conn
-	fmt.Printf("Node %s added to the network\n", address)
-}
-
-func (n *Network) RemoveNode(address string) {
-	n.mutex.Lock()
-	defer n.mutex.Unlock()
-	if _, exists := n.Nodes[address]; exists {
-		delete(n.Nodes, address)
-		fmt.Printf("Node %s removed from the network\n", address)
-	}
-}
-
-func (n *Network) BroadcastMessage(message []byte) {
-	n.mutex.Lock()
-	defer n.mutex.Unlock()
-	for address, conn := range n.Nodes {
-		_, err := conn.Write(message)
-		if err != nil {
-			fmt.Printf("Failed to send message to node %s: %v\n", address, err)
-		}
-	}
+	AuthorityNodeAddress string
 }
diff --git a/cmd/node.go b/cmd/node.go
index 29e353c..744174b 100644
--- a/cmd/node.go
+++ b/cmd/node.go
@@ -9,20 +9,25 @@ import (
 
 var authorityAddress string
 
+// TODO: Port hinzuf√ºgen per Parameter -p --port
 var nodeCmd = &cobra.Command{
 	Use:   "node",
 	Short: "Start a node",
 	Long:  `Start a node either as an authority node or as a client node.`,
 	Run: func(cmd *cobra.Command, args []string) {
 		if authorityAddress == "" {
-			authorityPrivateKey, authorityPublicKey, _ := ed25519.GenerateKey(nil)
-			nodeInstance := NewNode(authorityPrivateKey, authorityPublicKey, "localhost:8080")
-			authorityNode := NewAuthorityNode(authorityPrivateKey, nodeInstance)
+			authorityPublicKey, authorityPrivateKey, _ := ed25519.GenerateKey(nil)
+			authorityNode := NewAuthorityNode(authorityPrivateKey, authorityPublicKey)
 			fmt.Println("Starting Authority Node...")
+      authorityNode.SetupAuthorityNodeRoutes()
+      authorityNode.Listen(":8080")
 		} else {
-			clientPrivateKey, clientPublicKey, _ := ed25519.GenerateKey(nil)
-			nodeInstance := NewNode(clientPrivateKey, clientPublicKey, authorityAddress)
+			clientPublicKey, clientPrivateKey, _ := ed25519.GenerateKey(nil)
+			node := NewNode(clientPrivateKey, clientPublicKey, authorityAddress)
 			fmt.Printf("Starting Client Node... Connecting to Authority Node at %s\n", authorityAddress)
+      node.SetupNodeRoutes()
+      go node.AuthorityNodeDiscovery()
+      node.Listen(":8080")
 		}
 	},
 }
diff --git a/cmd/sync.go b/cmd/sync.go
index 7420ab0..c32eb55 100644
--- a/cmd/sync.go
+++ b/cmd/sync.go
@@ -10,7 +10,7 @@ import (
 )
 
 type SyncRequest struct {
-	LastBlockHash string `json:"last_block_hash"`
+	LastBlockHash string `json:"lastBlockHash"`
 }
 
 type SyncResponse struct {
@@ -36,8 +36,9 @@ func (n *Node) SyncWithAuthorityNode(authorityNodeAddress string) error {
 		return fmt.Errorf("failed to decode sync response: %v", err)
 	}
 
+  n.Blockchain.Blocks = append(n.Blockchain.Blocks, syncResponse.Blocks...)
+
 	for _, block := range syncResponse.Blocks {
-		n.Blockchain.Blocks = append(n.Blockchain.Blocks, block)
 		n.Blockchain.BlockMap[fmt.Sprintf("%x", block.Hash)] = block
 	}
 
diff --git a/utils/crypto.go b/utils/crypto.go
index 7afb1d8..9c86c2c 100644
--- a/utils/crypto.go
+++ b/utils/crypto.go
@@ -3,13 +3,14 @@ package utils
 import (
 	"crypto/aes"
 	"crypto/cipher"
+	"crypto/ecdh"
 	"crypto/ecdsa"
 	"crypto/ed25519"
 	"crypto/elliptic"
 	"crypto/rand"
+	"crypto/sha256"
 	"fmt"
 	"io"
-	"math/big"
 )
 
 func GenerateKeys() (ed25519.PublicKey, ed25519.PrivateKey, error) {
@@ -78,17 +79,65 @@ func GenerateECDSAKeys() (*ecdsa.PrivateKey, error) {
 	return privateKey, nil
 }
 
-func EncryptWithPublicKey(data []byte, publicKey *ecdsa.PublicKey) ([]byte, error) {
-	aesKey := make([]byte, 32) // 32 Bytes = 256 Bit
-	if _, err := io.ReadFull(rand.Reader, aesKey); err != nil {
-		return nil, fmt.Errorf("failed to generate AES key: %v", err)
-	}
-
-	r, s, err := ecdsa.Sign(rand.Reader, &ecdsa.PrivateKey{D: big.NewInt(1), PublicKey: *publicKey}, aesKey)
-	if err != nil {
-		return nil, fmt.Errorf("failed to encrypt AES key: %v", err)
-	}
-	encryptedAESKey := append(r.Bytes(), s.Bytes()...)
+// Helper function to serialize a public key by concatenating X and Y coordinates
+func serializePublicKey(publicKey *ecdsa.PublicKey) []byte {
+    xBytes := publicKey.X.Bytes()
+    yBytes := publicKey.Y.Bytes()
+    return append(xBytes, yBytes...)
+}
 
-	return encryptedAESKey, nil
+// EncryptAESKeyWithPublicKey encrypts an AES key using the recipient's public key via ECDH
+func EncryptAESKeyWithPublicKey(aesKey []byte, publicKey *ecdsa.PublicKey) ([]byte, error) {
+    // Create an ECDH curve object
+    curve := ecdh.P256()
+
+    // Serialize the ECDSA public key into a single byte slice (concatenating X and Y coordinates)
+    recipientPubKeyBytes := serializePublicKey(publicKey)
+
+    // Convert the serialized ECDSA public key to the ECDH public key format
+    recipientPubKey, err := curve.NewPublicKey(recipientPubKeyBytes)
+    if err != nil {
+        return nil, fmt.Errorf("failed to convert public key: %v", err)
+    }
+
+    // Generate an ephemeral private key for ECDH
+    ephemeralPrivKey, err := curve.GenerateKey(rand.Reader)
+    if err != nil {
+        return nil, fmt.Errorf("failed to generate ephemeral private key: %v", err)
+    }
+
+    // Derive a shared secret using ECDH with the recipient's public key and ephemeral private key
+    sharedSecret, err := ephemeralPrivKey.ECDH(recipientPubKey)
+    if err != nil {
+        return nil, fmt.Errorf("failed to derive shared secret: %v", err)
+    }
+
+    // Hash the shared secret using SHA-256 to produce the AES key
+    sharedSecretHash := sha256.Sum256(sharedSecret)
+
+    // Use the shared secret hash as the AES key
+    block, err := aes.NewCipher(sharedSecretHash[:])
+    if err != nil {
+        return nil, fmt.Errorf("failed to create AES cipher: %v", err)
+    }
+
+    aesGCM, err := cipher.NewGCM(block)
+    if err != nil {
+        return nil, fmt.Errorf("failed to create AES-GCM: %v", err)
+    }
+
+    nonce := make([]byte, aesGCM.NonceSize())
+    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
+        return nil, fmt.Errorf("failed to generate nonce: %v", err)
+    }
+
+    // Encrypt the AES key
+    encryptedAESKey := aesGCM.Seal(nil, nonce, aesKey, nil)
+
+    // Include the ephemeral public key (in bytes) for the recipient to derive the shared secret later
+    ephemeralPubKeyBytes := ephemeralPrivKey.PublicKey().Bytes()
+    encryptedData := append(ephemeralPubKeyBytes, nonce...)
+    encryptedData = append(encryptedData, encryptedAESKey...)
+
+    return encryptedData, nil
 }
